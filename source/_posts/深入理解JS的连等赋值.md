---
title: 深入理解JS的连等赋值
date: 2018-03-18 14:39:40
tags:
  - JS
---

## 热门问题的抛出

```js
  var a = {n: 1}
  var b = a
  a.x = a = {n:2}

  console.log('a.x:', a.x)  // undefined
  console.log('a:', a)  // {n: 2}
  console.log('b:', b)  // {n: 1, x: {n: 2}}
```

<!-- more -->

按照人脑的思维:
- 前两步，变量`a`等于`{n: 1}`。通过赋值，变量b等于`{n: 1}`。
- 连等的时候，从右往左执行。变量`a`等于`{n: 2}`，`a`多了一个`x`的属性，属性值是`{n: 2}`。
- 打印出来分别是：
  ```js
    console.log('a.x:', a.x)  // {n: 2}  X
    console.log('a:', a)  // {n: 2, x; {n: 2}}  X
    console.log('b:', b)  // {n: 1}  X
  ```

怎么想也想不通为啥`a.x`是 `undefined`，`a`是`{n: 2}`，`b`是`{n: 1, x: {n: 2}}`

## 要解决这个问题，要搞懂以下东西

- 内存的运行机制
- JS引擎的解析过程，从左往右
- 连等赋值的执行方向，从右往左

## 内存的运行机制

说说我的理解吧，老师教的~

- 对于计算机内存来说，它存的东西分为两块，一块存储`变量名`，一块存储`变量值`
- 那为什么变量值值占这么多空间呢？对于计算机来说，变量名只是一个字符串，占非常小的空间。但变量值就不一样了，当数值非常大时，占的空间就很大
- 所以就有了**内存回收机制**，简单理解，就是当变量值没有被引用时，这个变量值就会被销毁，节省内存

<div style="width: 450px">
  {% asset_img p1.jpeg %}
</div>

例如图示，
```js
  var a = {n: 1}
  var b = {n: 2}
  var c = '123'
```
每个变量值存在于内存的前提是，有变量名引用它

当我做以下操作时：
```js
  c = b
```
'123'这个变量值就没有变量名引用了，就会被销毁

## 通过开头的例子解析JS引擎的解析过程、连等赋值的执行方向

```js
  var a = {n: 1}
  var b = a
  a.x = a = {n:2}
```

这道题需要用计算机的思维去理解，用人的思维的话，会搞不懂的。虽然代码写的是`=`，但对于计算机而言，是一个**引用/指向**的过程

- 如下图所示，`a`的引用是`{n: 1}`，`b`的引用是`{n: 1}`。
  <div style="width: 250px">
    {% asset_img p3.png %}
  </div>

- 重点是，执行到`a.x = a = {n:2}`，并不是直接的从右往左的执行过程。**而是计算机会先从左往右解析各个变量名，转换成变量值（计算机只会记变量值，人的话记变量名）。再从右往左执行赋值。**

  1. 如图截取的片段，计算机先从左往右解析各个变量名。第一个`a`指向`{n: 1}`， 第二个`a`指向`{n:1}`。变量名解析完成。就是下图这样的
    <div style="width: 250px">
      {% asset_img p4.png %}
    </div>

  2. 解析完成后，从右往左执行赋值
    - 第二个等号。`a`重新指向了`{n: 2}`。根据内存回收机制，因为`a`不再指向`{n: 1}`了，`{n: 1}`会被回收吗？ ----- 答案是不会，因为`b`还在引用`{n: 1}`
    - 第一个等号。重头戏来了，`a.x = (a = {n: 2})`前面说了，解析的时候，`a.x`被解析成了`{n: 1}.x`。所以执行赋值的时候，可以这样理解：`{n: 1}.x = {n: 2}`。`{n: 1}`多了一个`x`的属性，属性值是`{n: 2}`。也就是内存的变量值`{n: 1}`变成了`{n: 1, x: {n: 2}`

    <div style="width: 550px">
      {% asset_img p2.jpeg %}
    </div>

  3. 前两步解析 + 赋值完成后，就继续执行下面的代码了
  ```js
    console.log('a.x:', a.x)
    console.log('a:', a)
    console.log('b:', b)
  ```
    - `a.x`，`a`指向`{n: 2}`。但`{n: 2}`并没有`x`的属性，所以是`undefined`
    - `a`，很明显是`{n: 2}`
    - `b`，指向的是`{n: 1, x: {n: 2}`

## 延伸

```js
  var a = {n: 1}
  var b = a
  a.x = a
```
a、b的值分别是？

- 直接上图
  <div style="width: 250px">
    {% asset_img p5.jpeg %}
  </div>

- 解析
  - `a`和`b`都同时指向对象`{n: 1}`
  - 当执行`a.x = a`，先从左往右解析，第一个`a`和第二个a都指向`{n: 1}`。解析完之后开始赋值，`{n: 1}`多了一个`x`的属性，`x`指向它自己`{n: 1}`，造成了无限递归。
  - a、b 都指向`{n: 1, x: {n: 1, x: {...}}

- 所以一般都不会写这样的程序，非常耗内存

## 文档参考

- [由ES规范学JavaScript(二)：深入理解“连等赋值”问题](https://segmentfault.com/a/1190000004224719aaaaaaaa)
